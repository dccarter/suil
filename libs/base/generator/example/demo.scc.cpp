
//
// !!!Generated by scc DO NOT MODIFY!!!
// file: /workspace/libs/base/generator/example/demo.scc.cpp
// date: Nov  9 2022 13:36:00
//

#include "demo.scc.hpp"



#pragma region sbg/meta
using suil::Categories;

namespace iod {

    template <>
    const iod::EnumMeta<Categories>& Meta<Categories>() {

        static const EnumMeta<Categories> sMeta = {
            "Categories",
            {
                EnumEntry(Categories, Sports),
                EnumEntry(Categories, Household),
                EnumEntry(Categories, Groceries)
            },
            true
        };
        return sMeta;
    }
} // end namespace
#pragma endregion sbg/meta

#pragma region sbg/meta
namespace suil {

    const Deposit::Schema Deposit::Meta{};

    Deposit Deposit::fromJson(iod::json::parser& p) {
        Deposit tmp{};
        p >> p.spaces >> '{';
        iod::json::iod_attr_from_json(&Deposit::Meta, tmp, p);
        p >> p.spaces >> '}';
        return tmp;
    }

    void Deposit::toJson(iod::json::jstream& ss) const {
        suil::json::metaToJson(Ego, ss);
    }

    size_t Deposit::maxByteSize() const {
        return suil::metaMaxByteSize(Ego);
    }

    Deposit Deposit::fromWire(suil::Wire& w) {
        Deposit tmp{};
        suil::metaFromWire(tmp, w);
        return tmp;
    }

    void Deposit::toWire(suil::Wire& w) const {
        suil::metaToWire(Ego, w);
    }

} // end namespace
#pragma endregion sbg/meta

#pragma region sbg/meta
namespace suil {

    const Create::Schema Create::Meta{};

    Create Create::fromJson(iod::json::parser& p) {
        Create tmp{};
        p >> p.spaces >> '{';
        iod::json::iod_attr_from_json(&Create::Meta, tmp, p);
        p >> p.spaces >> '}';
        return tmp;
    }

    void Create::toJson(iod::json::jstream& ss) const {
        suil::json::metaToJson(Ego, ss);
    }

    size_t Create::maxByteSize() const {
        return suil::metaMaxByteSize(Ego);
    }

    Create Create::fromWire(suil::Wire& w) {
        Create tmp{};
        suil::metaFromWire(tmp, w);
        return tmp;
    }

    void Create::toWire(suil::Wire& w) const {
        suil::metaToWire(Ego, w);
    }

} // end namespace
#pragma endregion sbg/meta

#pragma region sbg/meta
namespace suil {

    const Withdraw::Schema Withdraw::Meta{};

    Withdraw Withdraw::fromJson(iod::json::parser& p) {
        Withdraw tmp{};
        p >> p.spaces >> '{';
        iod::json::iod_attr_from_json(&Withdraw::Meta, tmp, p);
        p >> p.spaces >> '}';
        return tmp;
    }

    void Withdraw::toJson(iod::json::jstream& ss) const {
        suil::json::metaToJson(Ego, ss);
    }

    size_t Withdraw::maxByteSize() const {
        return suil::metaMaxByteSize(Ego);
    }

    Withdraw Withdraw::fromWire(suil::Wire& w) {
        Withdraw tmp{};
        suil::metaFromWire(tmp, w);
        return tmp;
    }

    void Withdraw::toWire(suil::Wire& w) const {
        suil::metaToWire(Ego, w);
    }

} // end namespace
#pragma endregion sbg/meta

#pragma region sbg/meta
namespace suil {

    size_t Command::maxByteSize() const {
        std::size_t size{suil::VarInt(std::variant_size_v<CommandUnionVariant>).length()};
        std::visit([&](const auto& arg) {
            size += suil::Wire::maxByteSize(arg);
        }, Value);
        return size;
    }

    Command Command::fromWire(suil::Wire& w) {
        Command tmp{};
        suil::VarInt index{0};
        w >> index;
        switch(std::size_t(index)) {
            case 0: {
                tmp.Value = Deposit{};
                w >> (std::get<Deposit>(tmp.Value));
                break;
            }
            case 1: {
                tmp.Value = Create{};
                w >> (std::get<Create>(tmp.Value));
                break;
            }
            case 2: {
                tmp.Value = Withdraw{};
                w >> (std::get<Withdraw>(tmp.Value));
                break;
            }
            case std::variant_npos: {
                // invalid variant specified on other size
                break;
            }
            default:
                throw suil::UnsupportedUnionMember("Type '", std::size_t(index), "' is not a a member of this union");
        }
        return std::move(tmp);
    }

    void Command::toWire(suil::Wire& w) const {
        suil::VarInt sz{Value.index()};
        w << sz;
        if (Value.index() == std::variant_npos) {
            // invalid value, do not serialize
            return;
        }
        std::visit([&](const auto& arg) {
            w << arg;
        }, Value);
    }Command Command::fromJson(const std::string& schema, iod::json::parser& p) {
        Command tmp{};
        switch(index(schema)) {
        case 0: {
            Deposit deposit;
            iod::json_internals::iod_from_json_((Deposit *) 0, deposit, p);
            tmp = std::move(deposit);
            break;
        }
        case 1: {
            Create create;
            iod::json_internals::iod_from_json_((Create *) 0, create, p);
            tmp = std::move(create);
            break;
        }
        case 2: {
            Withdraw withdraw;
            iod::json_internals::iod_from_json_((Withdraw *) 0, withdraw, p);
            tmp = std::move(withdraw);
            break;
        }
        default:
            throw suil::UnsupportedUnionMember("Type '", std::size_t(index), "' is not a a member of this union");
        }
        return std::move(tmp);
    }
    const char* Command::name() const {
        switch(Value.index()) {
        case 0: {
            return "deposit";
            break;
        }
        case 1: {
            return "create";
            break;
        }
        case 2: {
            return "withdraw";
            break;
        }
        default:
            throw suil::UnsupportedUnionMember("Type '", std::size_t(index), "' is not a a member of this union");
        }
        return "";
    }

    int Command::index(const std::string& name) {
        if (name == "deposit") {
            return 0; 
        }
        else if (name == "create") {
            return 1; 
        }
        else if (name == "withdraw") {
            return 2; 
        }

        throw suil::UnsupportedUnionMember("Type '", name, "' is not a a member of this union");
        return int(std::variant_npos);
    }

} // end namespace
#pragma endregion sbg/meta

#pragma region sbg/json
namespace suil {

    const JsonOnly::Schema JsonOnly::Meta{};

    JsonOnly JsonOnly::fromJson(iod::json::parser& p) {
        JsonOnly tmp{};
        p >> p.spaces >> '{';
        iod::json::iod_attr_from_json(&JsonOnly::Meta, tmp, p);
        p >> p.spaces >> '}';
        return tmp;
    }

    void JsonOnly::toJson(iod::json::jstream& ss) const {
        suil::json::metaToJson(Ego, ss);
    }


} // end namespace
#pragma endregion sbg/json

#pragma region sbg/wire
namespace suil {

    size_t WireOnly::maxByteSize() const {
        std::size_t size{suil::VarInt(std::variant_size_v<WireOnlyUnionVariant>).length()};
        std::visit([&](const auto& arg) {
            size += suil::Wire::maxByteSize(arg);
        }, Value);
        return size;
    }

    WireOnly WireOnly::fromWire(suil::Wire& w) {
        WireOnly tmp{};
        suil::VarInt index{0};
        w >> index;
        switch(std::size_t(index)) {
            case 0: {
                tmp.Value = Deposit{};
                w >> (std::get<Deposit>(tmp.Value));
                break;
            }
            case 1: {
                tmp.Value = Withdraw{};
                w >> (std::get<Withdraw>(tmp.Value));
                break;
            }
            case 2: {
                tmp.Value = Create{};
                w >> (std::get<Create>(tmp.Value));
                break;
            }
            case std::variant_npos: {
                // invalid variant specified on other size
                break;
            }
            default:
                throw suil::UnsupportedUnionMember("Type '", std::size_t(index), "' is not a a member of this union");
        }
        return std::move(tmp);
    }

    void WireOnly::toWire(suil::Wire& w) const {
        suil::VarInt sz{Value.index()};
        w << sz;
        if (Value.index() == std::variant_npos) {
            // invalid value, do not serialize
            return;
        }
        std::visit([&](const auto& arg) {
            w << arg;
        }, Value);
    }
    const char* WireOnly::name() const {
        switch(Value.index()) {
        case 0: {
            return "deposit";
            break;
        }
        case 1: {
            return "withdraw";
            break;
        }
        case 2: {
            return "create";
            break;
        }
        default:
            throw suil::UnsupportedUnionMember("Type '", std::size_t(index), "' is not a a member of this union");
        }
        return "";
    }

    int WireOnly::index(const std::string& name) {
        if (name == "deposit") {
            return 0; 
        }
        else if (name == "withdraw") {
            return 1; 
        }
        else if (name == "create") {
            return 2; 
        }

        throw suil::UnsupportedUnionMember("Type '", name, "' is not a a member of this union");
        return int(std::variant_npos);
    }

} // end namespace
#pragma endregion sbg/wire

